# Задачи для планировщика (Scheduled Tasks)

Этот документ описывает фоновые задачи, которые должны выполняться по расписанию.

## Зачем нужны Scheduled Tasks?

В реальных приложениях часто требуется выполнять задачи автоматически:
- Очистка устаревших данных
- Отправка уведомлений
- Проверка состояния системы
- Синхронизация с внешними системами
- Обновление кешей

В нашем учебном проекте мы реализуем типичные задачи для e-commerce системы.

---

## Задача 1: Отмена просроченных заказов

### Бизнес-требование
Если заказ находится в статусе `PENDING` (ожидает оплаты) более 24 часов, его нужно автоматически отменить, чтобы освободить зарезервированный товар на складе.

### Техническая спецификация

**Расписание:** Каждое утро в 9:00

**Алгоритм:**
1. Найти все заказы со статусом `PENDING`
2. Отфильтровать те, у которых `order_date` старше 24 часов от текущего времени
3. Для каждого просроченного заказа:
   - Изменить статус на `CANCELLED`
   - Вернуть товары на склад (увеличить `in_stock` на количество из order_items)
   - Залогировать: ID заказа, ID клиента, количество позиций
4. Залогировать итоговую статистику: сколько заказов отменено, сколько товара возвращено

**Важные моменты:**
- Операция должна быть транзакционной (@Transactional)
- При ошибке на одном заказе - не останавливать обработку остальных (try-catch)
- Использовать ShedLock, чтобы задача не выполнялась на всех инстансах

**SQL запрос для понимания:**
```sql
SELECT o.order_id, o.customer_id, o.order_date
FROM orders o
WHERE o.status = 'pending'
  AND o.order_date < NOW() - INTERVAL '24 hours';
```

**Вопросы для размышления:**
- Что будет, если не использовать транзакцию?
- Как обработать ситуацию, если заказ уже был оплачен, но статус еще не обновился?
- Нужно ли проверять, что платеж не был создан?

---

## Задача 2: Уведомление о низких остатках

### Бизнес-требование
Склад должен знать, какие товары заканчиваются, чтобы вовремя заказать у поставщика.

### Техническая спецификация

**Расписание:** Каждый день в 10:00

**Алгоритм:**
1. Найти все товары, где `in_stock` меньше порогового значения (например, 10 единиц)
2. Сгруппировать по категориям
3. Залогировать результаты в удобном формате:
   ```
   [LOW STOCK ALERT] Category: Electronics
     - Product: Laptop (ID: 123), Stock: 3 units, Price: $999.99
     - Product: Mouse (ID: 456), Stock: 5 units, Price: $29.99
   Total: 2 products require restocking
   ```
4. (Опционально) Отправить email менеджеру склада

**Важные моменты:**
- Задача только для чтения (readOnly = true)
- Можно использовать кастомный запрос с JOIN к categories
- Пороговое значение можно сделать конфигурируемым (через application.properties)

**SQL запрос для понимания:**
```sql
SELECT c.category_name, p.product_id, p.product_name, p.in_stock, p.price
FROM products p
JOIN categories c ON p.category_id = c.category_id
WHERE p.in_stock < 10
ORDER BY c.category_name, p.in_stock ASC;
```

**Вопросы для размышления:**
- Нужна ли здесь транзакция?
- Как избежать спама, если товар давно закончился?
- Может ли задача замедлить работу приложения?

---

## Задача 3: Очистка старых отмененных заказов

### Бизнес-требование
Отмененные заказы хранить бесконечно нет смысла. Через 6 месяцев их можно удалить для экономии места в БД.

### Техническая спецификация

**Расписание:** Каждое воскресенье в 3:00 ночи (низкая нагрузка на систему)

**Алгоритм:**
1. Найти все заказы со статусом `CANCELLED`
2. Отфильтровать те, у которых `order_date` старше 6 месяцев
3. Удалить найденные заказы
   - Order_items и payments удалятся автоматически (cascade delete)
4. Залогировать количество удаленных заказов

**Важные моменты:**
- Операция должна быть транзакционной
- Проверить, что у заказа статус действительно CANCELLED (двойная проверка)
- Можно удалять порциями (batches), если заказов много
- Использовать ShedLock

**SQL запрос для понимания:**
```sql
DELETE FROM orders
WHERE status = 'cancelled'
  AND order_date < NOW() - INTERVAL '6 months';
```

**Вопросы для размышления:**
- Безопасно ли удалять данные без backup?
- Может быть лучше архивировать в отдельную таблицу?
- Что если во время удаления произойдет ошибка?

---

## Задача 4: Обновление популярности товаров (усложненная)

### Бизнес-требование
Рассчитывать рейтинг популярности товаров на основе продаж за последние 30 дней.

### Техническая спецификация

**Расписание:** Каждую ночь в 2:00

**Алгоритм:**
1. Для каждого товара подсчитать количество продаж за последние 30 дней
2. Рассчитать популярность: `total_sold * average_price`
3. (Опционально) Сохранить результат в отдельную таблицу `product_statistics`

**SQL запрос для понимания:**
```sql
SELECT 
    p.product_id,
    p.product_name,
    COALESCE(SUM(oi.quantity), 0) as total_sold,
    COALESCE(SUM(oi.quantity * oi.unit_price), 0) as total_revenue
FROM products p
LEFT JOIN order_items oi ON p.product_id = oi.product_id
LEFT JOIN orders o ON oi.order_id = o.order_id
WHERE o.order_date >= NOW() - INTERVAL '30 days'
  AND o.status IN ('paid', 'shipped', 'delivered')
GROUP BY p.product_id, p.product_name
ORDER BY total_revenue DESC;
```

---

## Настройка ShedLock

### Зачем нужен?
При запуске нескольких инстансов приложения (для отказоустойчивости), каждый инстанс будет пытаться выполнить scheduled задачи. ShedLock гарантирует выполнение только на одном инстансе.

### Конфигурация

**Таблица shedlock** уже создана миграцией `002-shedlock-table.sql`.

**Параметры блокировки:**

| Параметр | Значение | Объяснение |
|----------|----------|------------|
| name | Уникальное имя задачи | Идентификатор в таблице shedlock |
| lockAtMostFor | Максимальное время | Защита от зависших задач (если инстанс упал) |
| lockAtLeastFor | Минимальное время | Предотвращение частого выполнения |

**Пример настройки:**
```java
@SchedulerLock(
    name = "cancelExpiredOrders",
    lockAtMostFor = "15m",  // Задача точно завершится за 15 минут
    lockAtLeastFor = "5m"   // Не запускать чаще раза в 5 минут
)
```

### Как это работает?

1. Инстанс A пытается получить блокировку → вставляет запись в `shedlock` с `lock_until`
2. Инстанс B пытается получить блокировку → видит активную блокировку → пропускает выполнение
3. Инстанс A завершает задачу → обновляет `lock_until` на прошедшее время (освобождает)
4. Если инстанс A упал → блокировка автоматически освободится через `lockAtMostFor`

---

## Мониторинг и логирование

### Что логировать?

**Обязательно:**
- Начало выполнения задачи (с timestamp)
- Конец выполнения задачи (с длительностью)
- Количество обработанных записей
- Ошибки (с полным stack trace)

**Пример структуры логов:**
```
[2024-01-15 09:00:00] INFO  [SCHEDULER] Starting task: cancelExpiredOrders
[2024-01-15 09:00:05] INFO  [SCHEDULER] Found 15 expired orders
[2024-01-15 09:00:12] INFO  [SCHEDULER] Cancelled order #1234 for customer #567
...
[2024-01-15 09:00:45] INFO  [SCHEDULER] Task completed: cancelExpiredOrders
                                        Duration: 45s, Cancelled: 15 orders, Returned stock: 87 units
```

### Метрики для отслеживания

- Время выполнения каждой задачи
- Количество обработанных записей
- Количество ошибок
- Частота пропусков (когда ShedLock блокирует выполнение)

---

## Тестирование Scheduled Tasks

### Unit тесты
- Мокировать репозитории
- Проверять корректность бизнес-логики
- Тестировать edge cases (пустой результат, большое количество данных)

### Integration тесты
- Использовать TestContainers с PostgreSQL
- Подготовить тестовые данные (fixtures)
- Проверять состояние БД до и после выполнения задачи

### Ручное тестирование
- Можно добавить REST endpoint для ручного запуска задачи (только для dev!)
- Изменить cron на более частое выполнение для тестирования

---

## Дополнительные задачи для экспериментов (опционально)

1. **Reminder об неоплаченных заказах**
   - Каждый час проверять заказы в статусе PENDING старше 6 часов
   - Логировать "напоминание" клиенту

2. **Синхронизация цен с внешним API**
   - Каждые 4 часа обновлять цены товаров
   - (можно мокировать внешний API)

3. **Backup статистики**
   - Раз в сутки сохранять snapshot метрик (количество заказов, выручка)

4. **Health check**
   - Каждые 5 минут проверять доступность БД
   - Логировать warning при проблемах

---

## Что изучить

**Обязательно:**
- Cron expressions (синтаксис и примеры)
- @Scheduled аннотация и её параметры
- ShedLock и распределенные системы
- Транзакции в scheduled tasks

**Дополнительно:**
- Thread pools для scheduled tasks
- Async task execution
- Quartz Scheduler (альтернатива)
- Мониторинг задач (Spring Boot Actuator)

**Полезные ссылки:**
- https://crontab.guru/ - cron expressions
- TECHNICAL_REQUIREMENTS.md раздел 8
- CODE_EXAMPLES_AND_PATTERNS.md раздел 7
- TECHNOLOGIES_AND_LIBRARIES.md разделы 3 и 4

